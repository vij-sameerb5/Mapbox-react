{"ast":null,"code":"'use strict';\n\nvar nanoid = require('nanoid').nanoid;\n\n/**\n * Construct a new mapbox event client to send interaction events to the mapbox event service\n * @param {Object} options options with which to create the service\n * @param {String} options.accessToken the mapbox access token to make requests\n * @param {Number} [options.flushInterval=1000] the number of ms after which to flush the event queue\n * @param {Number} [options.maxQueueSize=100] the number of events to queue before flushing\n * @private\n */\nfunction MapboxEventManager(options) {\n  this.origin = options.origin || 'https://api.mapbox.com';\n  this.endpoint = 'events/v2';\n  this.access_token = options.accessToken;\n  this.version = '0.3.0';\n  this.pluginSessionID = this.generateSessionID();\n  this.sessionIncrementer = 0;\n  this.userAgent = this.getUserAgent();\n  this.options = options;\n  this.send = this.send.bind(this);\n\n  // parse global options to be sent with each request\n  this.countries = options.countries ? options.countries.split(\",\") : null;\n  this.types = options.types ? options.types.split(\",\") : null;\n  this.bbox = options.bbox ? options.bbox : null;\n  this.language = options.language ? options.language.split(\",\") : null;\n  this.limit = options.limit ? +options.limit : null;\n  this.locale = navigator.language || null;\n  this.enableEventLogging = this.shouldEnableLogging(options);\n  this.eventQueue = new Array();\n  this.flushInterval = options.flushInterval || 1000;\n  this.maxQueueSize = options.maxQueueSize || 100;\n  this.timer = this.flushInterval ? setTimeout(this.flush.bind(this), this.flushInterval) : null;\n  // keep some state to deduplicate requests if necessary\n  this.lastSentInput = \"\";\n  this.lastSentIndex = 0;\n}\nMapboxEventManager.prototype = {\n  /**\n     * Send a search.select event to the mapbox events service\n     * This event marks the array index of the item selected by the user out of the array of possible options\n     * @private\n     * @param {Object} selected the geojson feature selected by the user\n     * @param {Object} geocoder a mapbox-gl-geocoder instance\n     * @returns {Promise}\n     */\n  select: function (selected, geocoder) {\n    var payload = this.getEventPayload('search.select', geocoder, {\n      selectedFeature: selected\n    });\n    if (!payload) return; // reject malformed event\n    if (payload.resultIndex === this.lastSentIndex && payload.queryString === this.lastSentInput || payload.resultIndex == -1) {\n      // don't log duplicate events if the user re-selected the same feature on the same search\n      return;\n    }\n    this.lastSentIndex = payload.resultIndex;\n    this.lastSentInput = payload.queryString;\n    return this.push(payload);\n  },\n  /**\n     * Send a search-start event to the mapbox events service\n     * This turnstile event marks when a user starts a new search\n     * @private\n     * @param {Object} geocoder a mapbox-gl-geocoder instance\n     * @returns {Promise}\n     */\n  start: function (geocoder) {\n    var payload = this.getEventPayload('search.start', geocoder);\n    if (!payload) return; // reject malformed event\n    return this.push(payload);\n  },\n  /**\n   * Send a search-keyevent event to the mapbox events service\n   * This event records each keypress in sequence\n   * @private\n   * @param {Object} keyEvent the keydown event to log\n   * @param {Object} geocoder a mapbox-gl-geocoder instance\n   * \n   */\n  keyevent: function (keyEvent, geocoder) {\n    //pass invalid event\n    if (!keyEvent.key) return;\n    // don't send events for keys that don't change the input\n    // TAB, ESC, LEFT, RIGHT, ENTER, UP, DOWN\n    if (keyEvent.metaKey || [9, 27, 37, 39, 13, 38, 40].indexOf(keyEvent.keyCode) !== -1) return;\n    var payload = this.getEventPayload('search.keystroke', geocoder, {\n      key: keyEvent.key\n    });\n    if (!payload) return; // reject malformed event\n    return this.push(payload);\n  },\n  /**\n   * Send an event to the events service\n   *\n   * The event is skipped if the instance is not enabled to send logging events\n   *\n   * @private\n   * @param {Object} payload the http POST body of the event\n   * @param {Function} [callback] a callback function to invoke when the send has completed\n   * @returns {Promise}\n   */\n  send: function (payload, callback) {\n    if (!this.enableEventLogging) {\n      if (callback) return callback();\n      return;\n    }\n    var options = this.getRequestOptions(payload);\n    this.request(options, function (err) {\n      if (err) return this.handleError(err, callback);\n      if (callback) {\n        return callback();\n      }\n    }.bind(this));\n  },\n  /**\n   * Get http request options\n   * @private\n   * @param {*} payload\n   */\n  getRequestOptions: function (payload) {\n    if (!Array.isArray(payload)) payload = [payload];\n    var options = {\n      // events must be sent with POST\n      method: \"POST\",\n      host: this.origin,\n      path: this.endpoint + \"?access_token=\" + this.access_token,\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(payload) //events are arrays\n    };\n    return options;\n  },\n  /**\n   * Get the event payload to send to the events service\n   * Most payload properties are shared across all events\n   * @private\n   * @param {String} event the name of the event to send to the events service. Valid options are 'search.start', 'search.select', 'search.feedback'.\n   * @param {Object} geocoder a mapbox-gl-geocoder instance\n   * @param {Object} eventArgs Additional arguments needed for certain event types\n   * @param {Object} eventArgs.key The key pressed by the user\n   * @param {Object} eventArgs.selectedFeature GeoJSON Feature selected by the user\n   * @returns {Object} an event payload\n   */\n  getEventPayload: function (event, geocoder, eventArgs = {}) {\n    // Make sure required arguments are present for certain event types\n    if (event === 'search.select' && !eventArgs.selectedFeature || event === 'search.keystroke' && !eventArgs.key) {\n      return null;\n    }\n\n    // Handle proximity, whether null, lat/lng coordinate object, or 'ip'\n    var proximity;\n    if (!geocoder.options.proximity) {\n      proximity = null;\n    } else if (typeof geocoder.options.proximity === 'object') {\n      proximity = [geocoder.options.proximity.longitude, geocoder.options.proximity.latitude];\n    } else if (geocoder.options.proximity === 'ip') {\n      var ipProximityHeader = geocoder._headers ? geocoder._headers['ip-proximity'] : null;\n      if (ipProximityHeader && typeof ipProximityHeader === 'string') {\n        proximity = ipProximityHeader.split(',').map(parseFloat);\n      } else {\n        proximity = [999, 999]; // Alias for 'ip' in event logs\n      }\n    } else {\n      proximity = geocoder.options.proximity;\n    }\n    var zoom = geocoder._map ? geocoder._map.getZoom() : undefined;\n    var payload = {\n      event: event,\n      version: this.getEventSchemaVersion(event),\n      created: +new Date(),\n      sessionIdentifier: this.getSessionId(),\n      country: this.countries,\n      userAgent: this.userAgent,\n      language: this.language,\n      bbox: this.bbox,\n      types: this.types,\n      endpoint: 'mapbox.places',\n      autocomplete: geocoder.options.autocomplete,\n      fuzzyMatch: geocoder.options.fuzzyMatch,\n      proximity: proximity,\n      limit: geocoder.options.limit,\n      routing: geocoder.options.routing,\n      worldview: geocoder.options.worldview,\n      mapZoom: zoom,\n      keyboardLocale: this.locale\n    };\n\n    // get the text in the search bar\n    if (event === \"search.select\") {\n      payload.queryString = geocoder.inputString;\n    } else if (event != \"search.select\" && geocoder._inputEl) {\n      payload.queryString = geocoder._inputEl.value;\n    } else {\n      payload.queryString = geocoder.inputString;\n    }\n\n    // add additional properties for certain event types\n    if (['search.keystroke', 'search.select'].includes(event)) {\n      payload.path = 'geocoding/v5/mapbox.places';\n    }\n    if (event === 'search.keystroke' && eventArgs.key) {\n      payload.lastAction = eventArgs.key;\n    } else if (event === 'search.select' && eventArgs.selectedFeature) {\n      var selected = eventArgs.selectedFeature;\n      var resultIndex = this.getSelectedIndex(selected, geocoder);\n      payload.resultIndex = resultIndex;\n      payload.resultPlaceName = selected.place_name;\n      payload.resultId = selected.id;\n      if (selected.properties) {\n        payload.resultMapboxId = selected.properties.mapbox_id;\n      }\n      if (geocoder._typeahead) {\n        var results = geocoder._typeahead.data;\n        if (results && results.length > 0) {\n          payload.suggestionIds = this.getSuggestionIds(results);\n          payload.suggestionNames = this.getSuggestionNames(results);\n          payload.suggestionTypes = this.getSuggestionTypes(results);\n          payload.suggestionSources = this.getSuggestionSources(results);\n        }\n      }\n    }\n\n    // Finally, validate that required properties are present for API compatibility\n    if (!this.validatePayload(payload)) {\n      return null;\n    }\n    return payload;\n  },\n  /**\n   * Wraps the request function for easier testing\n   * Make an http request and invoke a callback\n   * @private\n   * @param {Object} opts options describing the http request to be made\n   * @param {Function} callback the callback to invoke when the http request is completed\n   */\n  request: function (opts, callback) {\n    var xhttp = new XMLHttpRequest();\n    xhttp.onreadystatechange = function () {\n      if (this.readyState == 4) {\n        if (this.status == 204) {\n          //success\n          return callback(null);\n        } else {\n          return callback(this.statusText);\n        }\n      }\n    };\n    xhttp.open(opts.method, opts.host + '/' + opts.path, true);\n    for (var header in opts.headers) {\n      var headerValue = opts.headers[header];\n      xhttp.setRequestHeader(header, headerValue);\n    }\n    xhttp.send(opts.body);\n  },\n  /**\n   * Handle an error that occurred while making a request\n   * @param {Object} err an error instance to log\n   * @private\n   */\n  handleError: function (err, callback) {\n    if (callback) return callback(err);\n  },\n  /**\n   * Generate a session ID to be returned with all of the searches made by this geocoder instance\n   * ID is random and cannot be tracked across sessions\n   * @private\n   */\n  generateSessionID: function () {\n    return nanoid();\n  },\n  /**\n   * Get the a unique session ID for the current plugin session and increment the session counter.\n   *\n   * @returns {String} The session ID\n   */\n  getSessionId: function () {\n    return this.pluginSessionID + '.' + this.sessionIncrementer;\n  },\n  /**\n   * Get a user agent string to send with the request to the events service\n   * @private\n   */\n  getUserAgent: function () {\n    return 'mapbox-gl-geocoder.' + this.version + \".\" + navigator.userAgent;\n  },\n  /**\n     * Get the 0-based numeric index of the item that the user selected out of the list of options\n     * @private\n     * @param {Object} selected the geojson feature selected by the user\n     * @param {Object} geocoder a Mapbox-GL-Geocoder instance\n     * @returns {Number} the index of the selected result\n     */\n  getSelectedIndex: function (selected, geocoder) {\n    if (!geocoder._typeahead) return;\n    var results = geocoder._typeahead.data;\n    var selectedID = selected.id;\n    var resultIDs = results.map(function (feature) {\n      return feature.id;\n    });\n    var selectedIdx = resultIDs.indexOf(selectedID);\n    return selectedIdx;\n  },\n  getSuggestionIds: function (results) {\n    return results.map(function (feature) {\n      if (feature.properties) {\n        return feature.properties.mapbox_id || '';\n      }\n      return feature.id || '';\n    });\n  },\n  getSuggestionNames: function (results) {\n    return results.map(function (feature) {\n      return feature.place_name || '';\n    });\n  },\n  getSuggestionTypes: function (results) {\n    return results.map(function (feature) {\n      if (feature.place_type && Array.isArray(feature.place_type)) {\n        return feature.place_type[0] || '';\n      }\n      return '';\n    });\n  },\n  getSuggestionSources: function (results) {\n    return results.map(function (feature) {\n      return feature._source || '';\n    });\n  },\n  /**\n   * Get the correct schema version for the event\n   * @private\n   * @param {String} event Name of the event\n   * @returns \n   */\n  getEventSchemaVersion: function (event) {\n    if (['search.keystroke', 'search.select'].includes(event)) {\n      return '2.2';\n    } else {\n      return '2.0';\n    }\n  },\n  /**\n   * Checks if a payload has all the required properties for the event type\n   * @private\n   * @param {Object} payload \n   * @returns \n   */\n  validatePayload: function (payload) {\n    if (!payload || !payload.event) return false;\n    var searchStartRequiredProps = ['event', 'created', 'sessionIdentifier', 'queryString'];\n    var searchKeystrokeRequiredProps = ['event', 'created', 'sessionIdentifier', 'queryString', 'lastAction'];\n    var searchSelectRequiredProps = ['event', 'created', 'sessionIdentifier', 'queryString', 'resultIndex', 'path', 'suggestionIds'];\n    var event = payload.event;\n    if (event === 'search.start') {\n      return this.objectHasRequiredProps(payload, searchStartRequiredProps);\n    } else if (event === 'search.keystroke') {\n      return this.objectHasRequiredProps(payload, searchKeystrokeRequiredProps);\n    } else if (event === 'search.select') {\n      return this.objectHasRequiredProps(payload, searchSelectRequiredProps);\n    }\n    return true;\n  },\n  /**\n   * Checks of an object has all the required properties\n   * @private\n   * @param {Object} obj \n   * @param {Array<String>} requiredProps \n   * @returns \n   */\n  objectHasRequiredProps: function (obj, requiredProps) {\n    return requiredProps.every(function (prop) {\n      if (prop === 'queryString') {\n        return typeof obj[prop] === 'string' && obj[prop].length > 0;\n      }\n      return obj[prop] !== undefined;\n    });\n  },\n  /**\n     * Check whether events should be logged\n     * Clients using a localGeocoder or an origin other than mapbox should not have events logged\n     * @private\n     */\n  shouldEnableLogging: function (options) {\n    if (options.enableEventLogging === false) return false;\n    if (options.origin && options.origin !== 'https://api.mapbox.com') return false;\n    return true;\n  },\n  /**\n   * Flush out the event queue by sending events to the events service\n   * @private\n   */\n  flush: function () {\n    if (this.eventQueue.length > 0) {\n      this.send(this.eventQueue);\n      this.eventQueue = new Array();\n    }\n    // //reset the timer\n    if (this.timer) clearTimeout(this.timer);\n    if (this.flushInterval) this.timer = setTimeout(this.flush.bind(this), this.flushInterval);\n  },\n  /**\n   * Push event into the pending queue\n   * @param {Object} evt the event to send to the events service\n   * @param {Boolean} forceFlush indicates that the event queue should be flushed after adding this event regardless of size of the queue\n   * @private\n   */\n  push: function (evt, forceFlush) {\n    this.eventQueue.push(evt);\n    if (this.eventQueue.length >= this.maxQueueSize || forceFlush) {\n      this.flush();\n    }\n  },\n  /**\n   * Flush any remaining events from the queue before it is removed\n   * @private\n   */\n  remove: function () {\n    this.flush();\n  }\n};\nmodule.exports = MapboxEventManager;","map":{"version":3,"names":["nanoid","require","MapboxEventManager","options","origin","endpoint","access_token","accessToken","version","pluginSessionID","generateSessionID","sessionIncrementer","userAgent","getUserAgent","send","bind","countries","split","types","bbox","language","limit","locale","navigator","enableEventLogging","shouldEnableLogging","eventQueue","Array","flushInterval","maxQueueSize","timer","setTimeout","flush","lastSentInput","lastSentIndex","prototype","select","selected","geocoder","payload","getEventPayload","selectedFeature","resultIndex","queryString","push","start","keyevent","keyEvent","key","metaKey","indexOf","keyCode","callback","getRequestOptions","request","err","handleError","isArray","method","host","path","headers","body","JSON","stringify","event","eventArgs","proximity","longitude","latitude","ipProximityHeader","_headers","map","parseFloat","zoom","_map","getZoom","undefined","getEventSchemaVersion","created","Date","sessionIdentifier","getSessionId","country","autocomplete","fuzzyMatch","routing","worldview","mapZoom","keyboardLocale","inputString","_inputEl","value","includes","lastAction","getSelectedIndex","resultPlaceName","place_name","resultId","id","properties","resultMapboxId","mapbox_id","_typeahead","results","data","length","suggestionIds","getSuggestionIds","suggestionNames","getSuggestionNames","suggestionTypes","getSuggestionTypes","suggestionSources","getSuggestionSources","validatePayload","opts","xhttp","XMLHttpRequest","onreadystatechange","readyState","status","statusText","open","header","headerValue","setRequestHeader","selectedID","resultIDs","feature","selectedIdx","place_type","_source","searchStartRequiredProps","searchKeystrokeRequiredProps","searchSelectRequiredProps","objectHasRequiredProps","obj","requiredProps","every","prop","clearTimeout","evt","forceFlush","remove","module","exports"],"sources":["/Users/sameershaik/Desktop/mapbox-react/node_modules/@mapbox/mapbox-gl-geocoder/lib/events.js"],"sourcesContent":["'use strict';\nvar nanoid = require('nanoid').nanoid;\n\n/**\n * Construct a new mapbox event client to send interaction events to the mapbox event service\n * @param {Object} options options with which to create the service\n * @param {String} options.accessToken the mapbox access token to make requests\n * @param {Number} [options.flushInterval=1000] the number of ms after which to flush the event queue\n * @param {Number} [options.maxQueueSize=100] the number of events to queue before flushing\n * @private\n */\nfunction MapboxEventManager(options) {\n  this.origin = options.origin || 'https://api.mapbox.com';\n  this.endpoint = 'events/v2';\n  this.access_token = options.accessToken;\n  this.version = '0.3.0'\n  this.pluginSessionID = this.generateSessionID();\n  this.sessionIncrementer = 0;\n  this.userAgent = this.getUserAgent();\n\n  this.options = options;\n  this.send = this.send.bind(this);\n\n\n  // parse global options to be sent with each request\n  this.countries = (options.countries) ? options.countries.split(\",\") : null;\n  this.types = (options.types) ? options.types.split(\",\") : null;\n  this.bbox = (options.bbox) ? options.bbox : null;\n  this.language = (options.language) ? options.language.split(\",\") : null;\n  this.limit = (options.limit) ? +options.limit : null;\n  this.locale = navigator.language || null;\n  this.enableEventLogging = this.shouldEnableLogging(options);\n  this.eventQueue = new Array();\n  this.flushInterval = options.flushInterval || 1000;\n  this.maxQueueSize = options.maxQueueSize || 100;\n  this.timer = (this.flushInterval) ? setTimeout(this.flush.bind(this), this.flushInterval) : null;\n  // keep some state to deduplicate requests if necessary\n  this.lastSentInput = \"\";\n  this.lastSentIndex = 0;\n}\n\nMapboxEventManager.prototype = {\n  /**\n     * Send a search.select event to the mapbox events service\n     * This event marks the array index of the item selected by the user out of the array of possible options\n     * @private\n     * @param {Object} selected the geojson feature selected by the user\n     * @param {Object} geocoder a mapbox-gl-geocoder instance\n     * @returns {Promise}\n     */\n  select: function(selected, geocoder){\n    var payload = this.getEventPayload('search.select', geocoder, { selectedFeature: selected });\n    if (!payload) return; // reject malformed event\n    if ((payload.resultIndex === this.lastSentIndex && payload.queryString === this.lastSentInput) || payload.resultIndex == -1) {\n      // don't log duplicate events if the user re-selected the same feature on the same search\n      return;\n    }\n    this.lastSentIndex = payload.resultIndex;\n    this.lastSentInput = payload.queryString;\n    return this.push(payload)\n  },\n\n  /**\n     * Send a search-start event to the mapbox events service\n     * This turnstile event marks when a user starts a new search\n     * @private\n     * @param {Object} geocoder a mapbox-gl-geocoder instance\n     * @returns {Promise}\n     */\n  start: function(geocoder){\n    var payload = this.getEventPayload('search.start', geocoder);\n    if (!payload) return; // reject malformed event\n    return this.push(payload);\n  },\n\n  /**\n   * Send a search-keyevent event to the mapbox events service\n   * This event records each keypress in sequence\n   * @private\n   * @param {Object} keyEvent the keydown event to log\n   * @param {Object} geocoder a mapbox-gl-geocoder instance\n   * \n   */\n  keyevent: function(keyEvent, geocoder){\n\n    //pass invalid event\n    if (!keyEvent.key) return;\n    // don't send events for keys that don't change the input\n    // TAB, ESC, LEFT, RIGHT, ENTER, UP, DOWN\n    if (keyEvent.metaKey || [9, 27, 37, 39, 13, 38, 40].indexOf(keyEvent.keyCode) !== -1) return;\n    var payload = this.getEventPayload('search.keystroke', geocoder, { key: keyEvent.key });\n    if (!payload) return; // reject malformed event\n    return this.push(payload);\n  },\n\n  /**\n   * Send an event to the events service\n   *\n   * The event is skipped if the instance is not enabled to send logging events\n   *\n   * @private\n   * @param {Object} payload the http POST body of the event\n   * @param {Function} [callback] a callback function to invoke when the send has completed\n   * @returns {Promise}\n   */\n  send: function (payload, callback) {\n    if (!this.enableEventLogging) {\n      if (callback) return callback();\n      return;\n    }\n    var options = this.getRequestOptions(payload);\n    this.request(options, function(err){\n      if (err) return this.handleError(err, callback);\n      if (callback) {\n        return callback();\n      }\n    }.bind(this))\n  },\n  /**\n   * Get http request options\n   * @private\n   * @param {*} payload\n   */\n  getRequestOptions: function(payload){\n    if (!Array.isArray(payload)) payload = [payload];\n    var options = {\n      // events must be sent with POST\n      method: \"POST\",\n      host: this.origin,\n      path: this.endpoint +  \"?access_token=\" + this.access_token,\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body:JSON.stringify(payload) //events are arrays\n    }\n    return options\n  },\n\n  /**\n   * Get the event payload to send to the events service\n   * Most payload properties are shared across all events\n   * @private\n   * @param {String} event the name of the event to send to the events service. Valid options are 'search.start', 'search.select', 'search.feedback'.\n   * @param {Object} geocoder a mapbox-gl-geocoder instance\n   * @param {Object} eventArgs Additional arguments needed for certain event types\n   * @param {Object} eventArgs.key The key pressed by the user\n   * @param {Object} eventArgs.selectedFeature GeoJSON Feature selected by the user\n   * @returns {Object} an event payload\n   */\n  getEventPayload: function (event, geocoder, eventArgs = {}) {\n    // Make sure required arguments are present for certain event types\n    if (\n      (event === 'search.select' && !eventArgs.selectedFeature) ||\n      (event === 'search.keystroke' && !eventArgs.key)\n    ) {\n      return null;\n    }\n\n    // Handle proximity, whether null, lat/lng coordinate object, or 'ip'\n    var proximity;\n    if (!geocoder.options.proximity) {\n      proximity = null;\n    } else if (typeof geocoder.options.proximity === 'object') {\n      proximity = [geocoder.options.proximity.longitude, geocoder.options.proximity.latitude];\n    } else if (geocoder.options.proximity === 'ip') {\n      var ipProximityHeader = geocoder._headers ? geocoder._headers['ip-proximity'] : null;\n      if (ipProximityHeader && typeof ipProximityHeader === 'string') {\n        proximity = ipProximityHeader.split(',').map(parseFloat);\n      } else {\n        proximity = [999,999];  // Alias for 'ip' in event logs\n      }\n    } else {\n      proximity = geocoder.options.proximity;\n    }\n\n    var zoom = (geocoder._map) ? geocoder._map.getZoom() : undefined;\n    var payload = {\n      event: event,\n      version: this.getEventSchemaVersion(event),\n      created: +new Date(),\n      sessionIdentifier: this.getSessionId(),\n      country: this.countries,\n      userAgent: this.userAgent,\n      language: this.language,\n      bbox: this.bbox,\n      types: this.types,\n      endpoint: 'mapbox.places',\n      autocomplete: geocoder.options.autocomplete,\n      fuzzyMatch: geocoder.options.fuzzyMatch,\n      proximity: proximity,\n      limit: geocoder.options.limit,\n      routing: geocoder.options.routing,\n      worldview: geocoder.options.worldview,\n      mapZoom: zoom,\n      keyboardLocale: this.locale\n    }\n\n    // get the text in the search bar\n    if (event === \"search.select\"){\n      payload.queryString = geocoder.inputString;\n    } else if (event != \"search.select\" && geocoder._inputEl){\n      payload.queryString = geocoder._inputEl.value;\n    } else {\n      payload.queryString = geocoder.inputString;\n    }\n\n    // add additional properties for certain event types\n    if (['search.keystroke', 'search.select'].includes(event)) {\n      payload.path = 'geocoding/v5/mapbox.places';\n    }\n    if (event === 'search.keystroke' && eventArgs.key) {\n      payload.lastAction = eventArgs.key;\n    } else if (event === 'search.select' && eventArgs.selectedFeature) {\n      var selected = eventArgs.selectedFeature;\n      var resultIndex = this.getSelectedIndex(selected, geocoder);\n      payload.resultIndex = resultIndex;\n      payload.resultPlaceName = selected.place_name;\n      payload.resultId = selected.id;\n      if (selected.properties) {\n        payload.resultMapboxId = selected.properties.mapbox_id;\n      }\n      if (geocoder._typeahead) {\n        var results = geocoder._typeahead.data;\n        if (results && results.length > 0) {\n          payload.suggestionIds = this.getSuggestionIds(results);\n          payload.suggestionNames = this.getSuggestionNames(results);\n          payload.suggestionTypes = this.getSuggestionTypes(results);\n          payload.suggestionSources = this.getSuggestionSources(results);\n        }\n      }\n    }\n\n    // Finally, validate that required properties are present for API compatibility\n    if (!this.validatePayload(payload)) {\n      return null;\n    }\n\n    return payload;\n  },\n\n  /**\n   * Wraps the request function for easier testing\n   * Make an http request and invoke a callback\n   * @private\n   * @param {Object} opts options describing the http request to be made\n   * @param {Function} callback the callback to invoke when the http request is completed\n   */\n  request: function (opts, callback) {\n    var xhttp = new XMLHttpRequest();\n    xhttp.onreadystatechange = function() {\n      if (this.readyState == 4 ) {\n        if (this.status == 204){\n          //success\n          return callback(null);\n        }else {\n          return callback(this.statusText);\n        }\n      }\n    };\n\n    xhttp.open(opts.method, opts.host + '/' + opts.path, true);\n    for (var header in opts.headers){\n      var headerValue = opts.headers[header];\n      xhttp.setRequestHeader(header, headerValue)\n    }\n    xhttp.send(opts.body);\n  },\n\n  /**\n   * Handle an error that occurred while making a request\n   * @param {Object} err an error instance to log\n   * @private\n   */\n  handleError: function (err, callback) {\n    if (callback) return callback(err);\n  },\n\n  /**\n   * Generate a session ID to be returned with all of the searches made by this geocoder instance\n   * ID is random and cannot be tracked across sessions\n   * @private\n   */\n  generateSessionID: function () {\n    return nanoid();\n  },\n\n  /**\n   * Get the a unique session ID for the current plugin session and increment the session counter.\n   *\n   * @returns {String} The session ID\n   */\n  getSessionId: function(){\n    return this.pluginSessionID + '.' + this.sessionIncrementer;\n  },\n\n  /**\n   * Get a user agent string to send with the request to the events service\n   * @private\n   */\n  getUserAgent: function () {\n    return 'mapbox-gl-geocoder.' + this.version + \".\" + navigator.userAgent;\n  },\n\n  /**\n     * Get the 0-based numeric index of the item that the user selected out of the list of options\n     * @private\n     * @param {Object} selected the geojson feature selected by the user\n     * @param {Object} geocoder a Mapbox-GL-Geocoder instance\n     * @returns {Number} the index of the selected result\n     */\n  getSelectedIndex: function(selected, geocoder){\n    if (!geocoder._typeahead) return;\n    var results = geocoder._typeahead.data;\n    var selectedID = selected.id;\n    var resultIDs = results.map(function (feature) {\n      return feature.id;\n    });\n    var selectedIdx = resultIDs.indexOf(selectedID);\n    return selectedIdx;\n  },\n\n  getSuggestionIds: function (results) {\n    return results.map(function (feature) {\n      if (feature.properties) {\n        return feature.properties.mapbox_id || '';\n      }\n      return feature.id || '';\n    });\n  },\n\n  getSuggestionNames: function (results) {\n    return results.map(function (feature) {\n      return feature.place_name || '';\n    });\n  },\n  \n  getSuggestionTypes: function (results) {\n    return results.map(function (feature) {\n      if (feature.place_type && Array.isArray(feature.place_type)) {\n        return feature.place_type[0] || '';\n      }\n      return '';\n    });\n  },\n  \n  getSuggestionSources: function (results) {\n    return results.map(function (feature) {\n      return feature._source || '';\n    });\n  },\n\n  /**\n   * Get the correct schema version for the event\n   * @private\n   * @param {String} event Name of the event\n   * @returns \n   */\n  getEventSchemaVersion: function(event) {\n    if (['search.keystroke', 'search.select'].includes(event)) {\n      return '2.2';\n    } else {\n      return '2.0';\n    }\n  },\n\n  /**\n   * Checks if a payload has all the required properties for the event type\n   * @private\n   * @param {Object} payload \n   * @returns \n   */\n  validatePayload: function(payload) {\n    if (!payload || !payload.event) return false;\n\n    var searchStartRequiredProps = ['event', 'created', 'sessionIdentifier', 'queryString'];\n    var searchKeystrokeRequiredProps = ['event', 'created', 'sessionIdentifier', 'queryString', 'lastAction'];\n    var searchSelectRequiredProps = ['event', 'created', 'sessionIdentifier', 'queryString', 'resultIndex', 'path', 'suggestionIds'];\n\n    var event = payload.event;\n    if (event === 'search.start') {\n      return this.objectHasRequiredProps(payload, searchStartRequiredProps);\n    } else if (event === 'search.keystroke') {\n      return this.objectHasRequiredProps(payload, searchKeystrokeRequiredProps);\n    } else if (event === 'search.select') {\n      return this.objectHasRequiredProps(payload, searchSelectRequiredProps);\n    }\n\n    return true;\n  },\n\n  /**\n   * Checks of an object has all the required properties\n   * @private\n   * @param {Object} obj \n   * @param {Array<String>} requiredProps \n   * @returns \n   */\n  objectHasRequiredProps: function(obj, requiredProps) {\n    return requiredProps.every(function(prop) {\n      if (prop === 'queryString') {\n        return typeof obj[prop] === 'string' && obj[prop].length > 0;\n      }\n      return obj[prop] !== undefined;\n    });\n  },\n\n  /**\n     * Check whether events should be logged\n     * Clients using a localGeocoder or an origin other than mapbox should not have events logged\n     * @private\n     */\n  shouldEnableLogging: function(options){\n    if (options.enableEventLogging === false) return false;\n    if (options.origin && options.origin !== 'https://api.mapbox.com') return false;\n    return true;\n  },\n\n  /**\n   * Flush out the event queue by sending events to the events service\n   * @private\n   */\n  flush: function(){\n    if (this.eventQueue.length > 0){\n      this.send(this.eventQueue);\n      this.eventQueue = new Array();\n    }\n    // //reset the timer\n    if (this.timer)  clearTimeout(this.timer);\n    if (this.flushInterval) this.timer = setTimeout(this.flush.bind(this), this.flushInterval)\n  },\n\n  /**\n   * Push event into the pending queue\n   * @param {Object} evt the event to send to the events service\n   * @param {Boolean} forceFlush indicates that the event queue should be flushed after adding this event regardless of size of the queue\n   * @private\n   */\n  push: function(evt, forceFlush){\n    this.eventQueue.push(evt);\n    if (this.eventQueue.length >= this.maxQueueSize || forceFlush){\n      this.flush();\n    }\n  },\n\n  /**\n   * Flush any remaining events from the queue before it is removed\n   * @private\n   */\n  remove: function(){\n    this.flush();\n  }\n}\n\n\n\nmodule.exports = MapboxEventManager;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}