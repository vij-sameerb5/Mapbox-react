{"ast":null,"code":"'use strict';\n\n/**\n * Validators are functions which assert certain type.\n * They can return a string which can then be used\n * to display a helpful error message.\n * They can also return a function for a custom error message.\n */\nvar isPlainObject = require('is-plain-obj');\nvar xtend = require('xtend');\nvar DEFAULT_ERROR_PATH = 'value';\nvar NEWLINE_INDENT = '\\n  ';\nvar v = {};\n\n/**\n * Runners\n *\n * Take root validators and run assertion\n */\nv.assert = function (rootValidator, options) {\n  options = options || {};\n  return function (value) {\n    var message = validate(rootValidator, value);\n    // all good\n    if (!message) {\n      return;\n    }\n    var errorMessage = processMessage(message, options);\n    if (options.apiName) {\n      errorMessage = options.apiName + ': ' + errorMessage;\n    }\n    throw new Error(errorMessage);\n  };\n};\n\n/**\n * Higher Order Validators\n *\n * validators which take other validators as input\n * and output a new validator\n */\nv.shape = function shape(validatorObj) {\n  var validators = objectEntries(validatorObj);\n  return function shapeValidator(value) {\n    var validationResult = validate(v.plainObject, value);\n    if (validationResult) {\n      return validationResult;\n    }\n    var key, validator;\n    var errorMessages = [];\n    for (var i = 0; i < validators.length; i++) {\n      key = validators[i].key;\n      validator = validators[i].value;\n      validationResult = validate(validator, value[key]);\n      if (validationResult) {\n        // return [key].concat(validationResult);\n        errorMessages.push([key].concat(validationResult));\n      }\n    }\n    if (errorMessages.length < 2) {\n      return errorMessages[0];\n    }\n\n    // enumerate all the error messages\n    return function (options) {\n      errorMessages = errorMessages.map(function (message) {\n        var key = message[0];\n        var renderedMessage = processMessage(message, options).split('\\n').join(NEWLINE_INDENT); // indents any inner nesting\n        return '- ' + key + ': ' + renderedMessage;\n      });\n      var objectId = options.path.join('.');\n      var ofPhrase = objectId === DEFAULT_ERROR_PATH ? '' : ' of ' + objectId;\n      return 'The following properties' + ofPhrase + ' have invalid values:' + NEWLINE_INDENT + errorMessages.join(NEWLINE_INDENT);\n    };\n  };\n};\nv.strictShape = function strictShape(validatorObj) {\n  var shapeValidator = v.shape(validatorObj);\n  return function strictShapeValidator(value) {\n    var shapeResult = shapeValidator(value);\n    if (shapeResult) {\n      return shapeResult;\n    }\n    var invalidKeys = Object.keys(value).reduce(function (memo, valueKey) {\n      if (validatorObj[valueKey] === undefined) {\n        memo.push(valueKey);\n      }\n      return memo;\n    }, []);\n    if (invalidKeys.length !== 0) {\n      return function () {\n        return 'The following keys are invalid: ' + invalidKeys.join(', ');\n      };\n    }\n  };\n};\nv.arrayOf = function arrayOf(validator) {\n  return createArrayValidator(validator);\n};\nv.tuple = function tuple() {\n  var validators = Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);\n  return createArrayValidator(validators);\n};\n\n// Currently array validation fails when the first invalid item is found.\nfunction createArrayValidator(validators) {\n  var validatingTuple = Array.isArray(validators);\n  var getValidator = function (index) {\n    if (validatingTuple) {\n      return validators[index];\n    }\n    return validators;\n  };\n  return function arrayValidator(value) {\n    var validationResult = validate(v.plainArray, value);\n    if (validationResult) {\n      return validationResult;\n    }\n    if (validatingTuple && value.length !== validators.length) {\n      return 'an array with ' + validators.length + ' items';\n    }\n    for (var i = 0; i < value.length; i++) {\n      validationResult = validate(getValidator(i), value[i]);\n      if (validationResult) {\n        return [i].concat(validationResult);\n      }\n    }\n  };\n}\nv.required = function required(validator) {\n  function requiredValidator(value) {\n    if (value == null) {\n      return function (options) {\n        return formatErrorMessage(options, isArrayCulprit(options.path) ? 'cannot be undefined/null.' : 'is required.');\n      };\n    }\n    return validator.apply(this, arguments);\n  }\n  requiredValidator.__required = true;\n  return requiredValidator;\n};\nv.oneOfType = function oneOfType() {\n  var validators = Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);\n  return function oneOfTypeValidator(value) {\n    var messages = validators.map(function (validator) {\n      return validate(validator, value);\n    }).filter(Boolean);\n\n    // If we don't have as many messages as no. of validators,\n    // then at least one validator was ok with the value.\n    if (messages.length !== validators.length) {\n      return;\n    }\n\n    // check primitive type\n    if (messages.every(function (message) {\n      return message.length === 1 && typeof message[0] === 'string';\n    })) {\n      return orList(messages.map(function (m) {\n        return m[0];\n      }));\n    }\n\n    // Complex oneOfTypes like\n    // `v.oneOftypes(v.shape({name: v.string})`, `v.shape({name: v.number}))`\n    // are complex ¯\\_(ツ)_/¯. For the current scope only returning the longest message.\n    return messages.reduce(function (max, arr) {\n      return arr.length > max.length ? arr : max;\n    });\n  };\n};\n\n/**\n * Meta Validators\n * which take options as argument (not validators)\n * and return a new primitive validator\n */\nv.equal = function equal(compareWith) {\n  return function equalValidator(value) {\n    if (value !== compareWith) {\n      return JSON.stringify(compareWith);\n    }\n  };\n};\nv.oneOf = function oneOf() {\n  var options = Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);\n  var validators = options.map(function (value) {\n    return v.equal(value);\n  });\n  return v.oneOfType.apply(this, validators);\n};\nv.range = function range(compareWith) {\n  var min = compareWith[0];\n  var max = compareWith[1];\n  return function rangeValidator(value) {\n    var validationResult = validate(v.number, value);\n    if (validationResult || value < min || value > max) {\n      return 'number between ' + min + ' & ' + max + ' (inclusive)';\n    }\n  };\n};\n\n/**\n * Primitive validators\n *\n * simple validators which return a string or undefined\n */\nv.any = function any() {\n  return;\n};\nv.boolean = function boolean(value) {\n  if (typeof value !== 'boolean') {\n    return 'boolean';\n  }\n};\nv.number = function number(value) {\n  if (typeof value !== 'number') {\n    return 'number';\n  }\n};\nv.plainArray = function plainArray(value) {\n  if (!Array.isArray(value)) {\n    return 'array';\n  }\n};\nv.plainObject = function plainObject(value) {\n  if (!isPlainObject(value)) {\n    return 'object';\n  }\n};\nv.string = function string(value) {\n  if (typeof value !== 'string') {\n    return 'string';\n  }\n};\nv.func = function func(value) {\n  if (typeof value !== 'function') {\n    return 'function';\n  }\n};\nfunction validate(validator, value) {\n  // assertions are optional by default unless wrapped in v.require\n  if (value == null && !validator.hasOwnProperty('__required')) {\n    return;\n  }\n  var result = validator(value);\n  if (result) {\n    return Array.isArray(result) ? result : [result];\n  }\n}\nfunction processMessage(message, options) {\n  // message array follows the convention\n  // [...path, result]\n  // path is an array of object keys / array indices\n  // result is output of the validator\n  var len = message.length;\n  var result = message[len - 1];\n  var path = message.slice(0, len - 1);\n  if (path.length === 0) {\n    path = [DEFAULT_ERROR_PATH];\n  }\n  options = xtend(options, {\n    path: path\n  });\n  return typeof result === 'function' ? result(options) // allows customization of result\n  : formatErrorMessage(options, prettifyResult(result));\n}\nfunction orList(list) {\n  if (list.length < 2) {\n    return list[0];\n  }\n  if (list.length === 2) {\n    return list.join(' or ');\n  }\n  return list.slice(0, -1).join(', ') + ', or ' + list.slice(-1);\n}\nfunction prettifyResult(result) {\n  return 'must be ' + addArticle(result) + '.';\n}\nfunction addArticle(nounPhrase) {\n  if (/^an? /.test(nounPhrase)) {\n    return nounPhrase;\n  }\n  if (/^[aeiou]/i.test(nounPhrase)) {\n    return 'an ' + nounPhrase;\n  }\n  if (/^[a-z]/i.test(nounPhrase)) {\n    return 'a ' + nounPhrase;\n  }\n  return nounPhrase;\n}\nfunction formatErrorMessage(options, prettyResult) {\n  var arrayCulprit = isArrayCulprit(options.path);\n  var output = options.path.join('.') + ' ' + prettyResult;\n  var prepend = arrayCulprit ? 'Item at position ' : '';\n  return prepend + output;\n}\nfunction isArrayCulprit(path) {\n  return typeof path[path.length - 1] == 'number' || typeof path[0] == 'number';\n}\nfunction objectEntries(obj) {\n  return Object.keys(obj || {}).map(function (key) {\n    return {\n      key: key,\n      value: obj[key]\n    };\n  });\n}\nv.validate = validate;\nv.processMessage = processMessage;\nmodule.exports = v;","map":{"version":3,"names":["isPlainObject","require","xtend","DEFAULT_ERROR_PATH","NEWLINE_INDENT","v","assert","rootValidator","options","value","message","validate","errorMessage","processMessage","apiName","Error","shape","validatorObj","validators","objectEntries","shapeValidator","validationResult","plainObject","key","validator","errorMessages","i","length","push","concat","map","renderedMessage","split","join","objectId","path","ofPhrase","strictShape","strictShapeValidator","shapeResult","invalidKeys","Object","keys","reduce","memo","valueKey","undefined","arrayOf","createArrayValidator","tuple","Array","isArray","arguments","prototype","slice","call","validatingTuple","getValidator","index","arrayValidator","plainArray","required","requiredValidator","formatErrorMessage","isArrayCulprit","apply","__required","oneOfType","oneOfTypeValidator","messages","filter","Boolean","every","orList","m","max","arr","equal","compareWith","equalValidator","JSON","stringify","oneOf","range","min","rangeValidator","number","any","boolean","string","func","hasOwnProperty","result","len","prettifyResult","list","addArticle","nounPhrase","test","prettyResult","arrayCulprit","output","prepend","obj","module","exports"],"sources":["/Users/sameershaik/Desktop/mapbox-react/node_modules/@mapbox/fusspot/lib/index.js"],"sourcesContent":["'use strict';\n/**\n * Validators are functions which assert certain type.\n * They can return a string which can then be used\n * to display a helpful error message.\n * They can also return a function for a custom error message.\n */\nvar isPlainObject = require('is-plain-obj');\nvar xtend = require('xtend');\n\nvar DEFAULT_ERROR_PATH = 'value';\nvar NEWLINE_INDENT = '\\n  ';\n\nvar v = {};\n\n/**\n * Runners\n *\n * Take root validators and run assertion\n */\nv.assert = function(rootValidator, options) {\n  options = options || {};\n  return function(value) {\n    var message = validate(rootValidator, value);\n    // all good\n    if (!message) {\n      return;\n    }\n\n    var errorMessage = processMessage(message, options);\n\n    if (options.apiName) {\n      errorMessage = options.apiName + ': ' + errorMessage;\n    }\n\n    throw new Error(errorMessage);\n  };\n};\n\n/**\n * Higher Order Validators\n *\n * validators which take other validators as input\n * and output a new validator\n */\nv.shape = function shape(validatorObj) {\n  var validators = objectEntries(validatorObj);\n  return function shapeValidator(value) {\n    var validationResult = validate(v.plainObject, value);\n\n    if (validationResult) {\n      return validationResult;\n    }\n\n    var key, validator;\n    var errorMessages = [];\n\n    for (var i = 0; i < validators.length; i++) {\n      key = validators[i].key;\n      validator = validators[i].value;\n      validationResult = validate(validator, value[key]);\n\n      if (validationResult) {\n        // return [key].concat(validationResult);\n        errorMessages.push([key].concat(validationResult));\n      }\n    }\n\n    if (errorMessages.length < 2) {\n      return errorMessages[0];\n    }\n\n    // enumerate all the error messages\n    return function(options) {\n      errorMessages = errorMessages.map(function(message) {\n        var key = message[0];\n        var renderedMessage = processMessage(message, options)\n          .split('\\n')\n          .join(NEWLINE_INDENT); // indents any inner nesting\n        return '- ' + key + ': ' + renderedMessage;\n      });\n\n      var objectId = options.path.join('.');\n      var ofPhrase = objectId === DEFAULT_ERROR_PATH ? '' : ' of ' + objectId;\n\n      return (\n        'The following properties' +\n        ofPhrase +\n        ' have invalid values:' +\n        NEWLINE_INDENT +\n        errorMessages.join(NEWLINE_INDENT)\n      );\n    };\n  };\n};\n\nv.strictShape = function strictShape(validatorObj) {\n  var shapeValidator = v.shape(validatorObj);\n  return function strictShapeValidator(value) {\n    var shapeResult = shapeValidator(value);\n    if (shapeResult) {\n      return shapeResult;\n    }\n\n    var invalidKeys = Object.keys(value).reduce(function(memo, valueKey) {\n      if (validatorObj[valueKey] === undefined) {\n        memo.push(valueKey);\n      }\n      return memo;\n    }, []);\n\n    if (invalidKeys.length !== 0) {\n      return function() {\n        return 'The following keys are invalid: ' + invalidKeys.join(', ');\n      };\n    }\n  };\n};\n\nv.arrayOf = function arrayOf(validator) {\n  return createArrayValidator(validator);\n};\n\nv.tuple = function tuple() {\n  var validators = Array.isArray(arguments[0])\n    ? arguments[0]\n    : Array.prototype.slice.call(arguments);\n  return createArrayValidator(validators);\n};\n\n// Currently array validation fails when the first invalid item is found.\nfunction createArrayValidator(validators) {\n  var validatingTuple = Array.isArray(validators);\n  var getValidator = function(index) {\n    if (validatingTuple) {\n      return validators[index];\n    }\n    return validators;\n  };\n\n  return function arrayValidator(value) {\n    var validationResult = validate(v.plainArray, value);\n    if (validationResult) {\n      return validationResult;\n    }\n\n    if (validatingTuple && value.length !== validators.length) {\n      return 'an array with ' + validators.length + ' items';\n    }\n\n    for (var i = 0; i < value.length; i++) {\n      validationResult = validate(getValidator(i), value[i]);\n      if (validationResult) {\n        return [i].concat(validationResult);\n      }\n    }\n  };\n}\n\nv.required = function required(validator) {\n  function requiredValidator(value) {\n    if (value == null) {\n      return function(options) {\n        return formatErrorMessage(\n          options,\n          isArrayCulprit(options.path)\n            ? 'cannot be undefined/null.'\n            : 'is required.'\n        );\n      };\n    }\n    return validator.apply(this, arguments);\n  }\n  requiredValidator.__required = true;\n\n  return requiredValidator;\n};\n\nv.oneOfType = function oneOfType() {\n  var validators = Array.isArray(arguments[0])\n    ? arguments[0]\n    : Array.prototype.slice.call(arguments);\n  return function oneOfTypeValidator(value) {\n    var messages = validators\n      .map(function(validator) {\n        return validate(validator, value);\n      })\n      .filter(Boolean);\n\n    // If we don't have as many messages as no. of validators,\n    // then at least one validator was ok with the value.\n    if (messages.length !== validators.length) {\n      return;\n    }\n\n    // check primitive type\n    if (\n      messages.every(function(message) {\n        return message.length === 1 && typeof message[0] === 'string';\n      })\n    ) {\n      return orList(\n        messages.map(function(m) {\n          return m[0];\n        })\n      );\n    }\n\n    // Complex oneOfTypes like\n    // `v.oneOftypes(v.shape({name: v.string})`, `v.shape({name: v.number}))`\n    // are complex ¯\\_(ツ)_/¯. For the current scope only returning the longest message.\n    return messages.reduce(function(max, arr) {\n      return arr.length > max.length ? arr : max;\n    });\n  };\n};\n\n/**\n * Meta Validators\n * which take options as argument (not validators)\n * and return a new primitive validator\n */\nv.equal = function equal(compareWith) {\n  return function equalValidator(value) {\n    if (value !== compareWith) {\n      return JSON.stringify(compareWith);\n    }\n  };\n};\n\nv.oneOf = function oneOf() {\n  var options = Array.isArray(arguments[0])\n    ? arguments[0]\n    : Array.prototype.slice.call(arguments);\n  var validators = options.map(function(value) {\n    return v.equal(value);\n  });\n\n  return v.oneOfType.apply(this, validators);\n};\n\nv.range = function range(compareWith) {\n  var min = compareWith[0];\n  var max = compareWith[1];\n  return function rangeValidator(value) {\n    var validationResult = validate(v.number, value);\n\n    if (validationResult || value < min || value > max) {\n      return 'number between ' + min + ' & ' + max + ' (inclusive)';\n    }\n  };\n};\n\n/**\n * Primitive validators\n *\n * simple validators which return a string or undefined\n */\nv.any = function any() {\n  return;\n};\n\nv.boolean = function boolean(value) {\n  if (typeof value !== 'boolean') {\n    return 'boolean';\n  }\n};\n\nv.number = function number(value) {\n  if (typeof value !== 'number') {\n    return 'number';\n  }\n};\n\nv.plainArray = function plainArray(value) {\n  if (!Array.isArray(value)) {\n    return 'array';\n  }\n};\n\nv.plainObject = function plainObject(value) {\n  if (!isPlainObject(value)) {\n    return 'object';\n  }\n};\n\nv.string = function string(value) {\n  if (typeof value !== 'string') {\n    return 'string';\n  }\n};\n\nv.func = function func(value) {\n  if (typeof value !== 'function') {\n    return 'function';\n  }\n};\n\nfunction validate(validator, value) {\n  // assertions are optional by default unless wrapped in v.require\n  if (value == null && !validator.hasOwnProperty('__required')) {\n    return;\n  }\n\n  var result = validator(value);\n\n  if (result) {\n    return Array.isArray(result) ? result : [result];\n  }\n}\n\nfunction processMessage(message, options) {\n  // message array follows the convention\n  // [...path, result]\n  // path is an array of object keys / array indices\n  // result is output of the validator\n  var len = message.length;\n\n  var result = message[len - 1];\n  var path = message.slice(0, len - 1);\n\n  if (path.length === 0) {\n    path = [DEFAULT_ERROR_PATH];\n  }\n  options = xtend(options, { path: path });\n\n  return typeof result === 'function'\n    ? result(options) // allows customization of result\n    : formatErrorMessage(options, prettifyResult(result));\n}\n\nfunction orList(list) {\n  if (list.length < 2) {\n    return list[0];\n  }\n  if (list.length === 2) {\n    return list.join(' or ');\n  }\n  return list.slice(0, -1).join(', ') + ', or ' + list.slice(-1);\n}\n\nfunction prettifyResult(result) {\n  return 'must be ' + addArticle(result) + '.';\n}\n\nfunction addArticle(nounPhrase) {\n  if (/^an? /.test(nounPhrase)) {\n    return nounPhrase;\n  }\n  if (/^[aeiou]/i.test(nounPhrase)) {\n    return 'an ' + nounPhrase;\n  }\n  if (/^[a-z]/i.test(nounPhrase)) {\n    return 'a ' + nounPhrase;\n  }\n  return nounPhrase;\n}\n\nfunction formatErrorMessage(options, prettyResult) {\n  var arrayCulprit = isArrayCulprit(options.path);\n  var output = options.path.join('.') + ' ' + prettyResult;\n  var prepend = arrayCulprit ? 'Item at position ' : '';\n\n  return prepend + output;\n}\n\nfunction isArrayCulprit(path) {\n  return typeof path[path.length - 1] == 'number' || typeof path[0] == 'number';\n}\n\nfunction objectEntries(obj) {\n  return Object.keys(obj || {}).map(function(key) {\n    return { key: key, value: obj[key] };\n  });\n}\n\nv.validate = validate;\nv.processMessage = processMessage;\n\nmodule.exports = v;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}